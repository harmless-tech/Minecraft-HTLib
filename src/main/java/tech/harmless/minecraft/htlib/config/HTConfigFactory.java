package tech.harmless.minecraft.htlib.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.jetbrains.annotations.NotNull;
import tech.harmless.minecraft.htlib.HTLib;
import tech.harmless.minecraft.htlib.config.keys.HTKeyBoolean;
import tech.harmless.minecraft.htlib.config.keys.HTKeyBooleanArray;
import tech.harmless.minecraft.htlib.config.keys.HTKeyLong;
import tech.harmless.minecraft.htlib.config.keys.HTKeyLongArray;
import tech.harmless.minecraft.htlib.config.keys.HTKeyString;
import tech.harmless.minecraft.htlib.config.keys.HTKeyStringArray;
import tech.harmless.minecraft.htlib.util.HTReflection;
import tech.harmless.minecraft.htlib.util.error.HTRuntimeErrors;
import tech.harmless.minecraft.htlib.util.types.FinalTuple;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.stream.Collectors;

//TODO Allow for an interface to be used so more values can be generated by the user? (After HTLib config gen)
//TODO Add a way to prune/repair a config file??
//TODO Check for key collisions.
public final class HTConfigFactory {

    private static final String CONFIG_ROOT_DIR = "config/";
    private static final String CONFIG_FILE_EXT = ".json";

    @NotNull
    //TODO Remove the modID part, this should be gotten automatically?
    public static <T> T build(@NotNull final String modId, @NotNull final Class<T> c) {
        if(c.isAnnotationPresent(HTConfig.class) && !c.isEnum() && !c.isInterface() && !c.isAnnotation() &&
                HTReflection.hasDefaultConstructor(c)) {
            try {
                HTConfig rootConfig = c.getAnnotation(HTConfig.class);
                File f = getOrCreateFile(modId, rootConfig.configName(), rootConfig.inFolder());
                T instance = c.getConstructor().newInstance();

                // Read file.
                BufferedReader reader = new BufferedReader(new FileReader(f));
                String fileText = reader.lines().collect(Collectors.joining());
                reader.close();

                // Parse input.
                JsonElement jsonElement = JsonParser.parseString(fileText);
                JsonObject root = jsonElement.getAsJsonObject();

                // Root node.
                if(!rootConfig.rootComment().isEmpty())
                    root.addProperty("Comment", rootConfig.rootComment());

                // Keys.
                Field[] fields = c.getFields();
                for(Field field : fields)
                    getOrSetKey(instance, field, root);

                // Write to file.
                Gson gson = new GsonBuilder().setPrettyPrinting().create();
                BufferedWriter writer = new BufferedWriter(new FileWriter(f, false));
                writer.write(gson.toJson(jsonElement) + "\n");
                writer.close();

                return instance;
            }
            catch(InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | SecurityException | IOException e) {
                e.printStackTrace();
            }
        }

        throw new RuntimeException(HTRuntimeErrors.CONFIG_ERROR);
    }

    @NotNull
    private static File getOrCreateFile(String modId, String configName, boolean folder) throws IOException {
        File f = new File(CONFIG_ROOT_DIR + (folder ? modId + "/" : "") + configName + CONFIG_FILE_EXT);
        boolean exist = f.exists();

        if(!exist) {
            f.getParentFile().mkdirs();
            if(!f.createNewFile()) {
                HTLib.LOG.error("Could not create the config file " + f.getAbsolutePath());
                throw new RuntimeException(HTRuntimeErrors.CONFIG_ERROR);
            }

            BufferedWriter writer = new BufferedWriter(new FileWriter(f, false));
            writer.write("{}\n");
            writer.close();
        }

        return f;
    }

    private static void getOrSetKey(Object instance, Field field, JsonObject root) throws IllegalAccessException {
        if(field.isAnnotationPresent(HTKeyBoolean.class)) {
            HTKeyBoolean val = field.getAnnotation(HTKeyBoolean.class);
            FinalTuple<JsonObject, String> top = getOrCreateTop(root, val.key());

            if(!val.comment().isEmpty() && !top.x().has("Comment " + top.y()))
                top.x().addProperty("Comment " + top.y(), val.comment());

            if(!top.x().has(top.y()))
                top.x().addProperty(top.y(), val.defaultValue());
            else {
                if(field.getType() != boolean.class)
                    throw new RuntimeException(); //TODO Message.

                field.setBoolean(instance, val.defaultValue());
            }
        }
        else if(field.isAnnotationPresent(HTKeyLong.class)) {
            HTKeyLong val = field.getAnnotation(HTKeyLong.class);
            FinalTuple<JsonObject, String> top = getOrCreateTop(root, val.key());

            if(!val.comment().isEmpty() && !top.x().has("Comment " + top.y()))
                top.x().addProperty("Comment " + top.y(), val.comment());

            if(!top.x().has(top.y()))
                top.x().addProperty(top.y(), val.defaultValue());
            else {
                if(field.getType() != long.class)
                    throw new RuntimeException(); //TODO Message.

                field.setLong(instance, val.defaultValue());
            }
        }
        else if(field.isAnnotationPresent(HTKeyString.class)) {
            HTKeyString val = field.getAnnotation(HTKeyString.class);
            FinalTuple<JsonObject, String> top = getOrCreateTop(root, val.key());

            if(!val.comment().isEmpty() && !top.x().has("Comment " + top.y()))
                top.x().addProperty("Comment " + top.y(), val.comment());

            if(!top.x().has(top.y()))
                top.x().addProperty(top.y(), val.defaultValue());
            else {
                if(field.getType() != String.class)
                    throw new RuntimeException(); //TODO Message.

                field.set(instance, val.defaultValue());
            }
        }
        else if(field.isAnnotationPresent(HTKeyBooleanArray.class)) {
            //root.add("", (JsonElement) new JsonArray()); //TODO Add elements.
        }
        else if(field.isAnnotationPresent(HTKeyLongArray.class)) {
            //TODO
        }
        else if(field.isAnnotationPresent(HTKeyStringArray.class)) {
            //TODO
        }
    }

    @NotNull
    private static FinalTuple<JsonObject, String> getOrCreateTop(JsonObject root, String key) {
        String[] keyArr = key.split("\\."); //TODO Right regex?
        if(keyArr.length <= 1)
            return new FinalTuple<>(root, key);

        JsonObject top = root;
        for(int i = 0; i < keyArr.length - 1; i++) {
            if(!top.has(keyArr[i]))
                top.add(keyArr[i], new JsonObject());

            top = top.getAsJsonObject(keyArr[i]);
        }

        return new FinalTuple<>(top, keyArr[keyArr.length - 1]);
    }
}
